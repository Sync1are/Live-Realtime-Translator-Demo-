<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Notification Engine - Task Management</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      color: #333;
      margin-bottom: 30px;
    }

    .section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    h2 {
      color: #555;
      margin-bottom: 15px;
      font-size: 18px;
    }

    .controls {
      display: grid;
      gap: 15px;
    }

    .control-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 4px;
    }

    label {
      font-weight: 500;
      color: #333;
    }

    input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    input[type="time"] {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    button:hover {
      background: #0056b3;
    }

    button.secondary {
      background: #6c757d;
    }

    button.secondary:hover {
      background: #545b62;
    }

    .test-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }

    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 8px;
    }

    .stat-value {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .stat-label {
      font-size: 14px;
      opacity: 0.9;
    }

    .inbox-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .inbox-item {
      padding: 15px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: start;
    }

    .inbox-item:last-child {
      border-bottom: none;
    }

    .inbox-item.unread {
      background: #f0f8ff;
      font-weight: 500;
    }

    .inbox-content {
      flex: 1;
    }

    .inbox-date {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }

    .inbox-data {
      font-size: 14px;
      color: #333;
    }

    .status {
      margin-top: 10px;
      padding: 10px;
      background: #e8f5e9;
      border-left: 4px solid #4caf50;
      border-radius: 4px;
      font-size: 14px;
    }

    .status.error {
      background: #ffebee;
      border-left-color: #f44336;
    }

    /* Gamification Styles */
    .gamification-widget {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      padding: 25px;
      color: white;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }

    .xp-section {
      text-align: center;
      margin-bottom: 20px;
    }

    .xp-value {
      font-size: 48px;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .xp-label {
      font-size: 14px;
      opacity: 0.9;
    }

    .level-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .level-badge {
      background: rgba(255, 255, 255, 0.2);
      padding: 5px 15px;
      border-radius: 20px;
      font-weight: bold;
    }

    .progress-bar {
      width: 100%;
      height: 10px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 5px;
      overflow: hidden;
      margin-bottom: 20px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4caf50 0%, #8bc34a 100%);
      transition: width 0.3s ease;
    }

    .goals-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 20px;
    }

    .goal-card {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 8px;
    }

    .goal-title {
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 10px;
    }

    .goal-progress {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .goal-bar {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      overflow: hidden;
    }

    .goal-bar-fill {
      height: 100%;
      background: #4caf50;
      transition: width 0.3s ease;
    }

    .achievements-section {
      margin-top: 20px;
    }

    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      max-height: 200px;
      overflow-y: auto;
    }

    .achievement-badge {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .achievement-badge:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.05);
    }

    .achievement-badge.unlocked {
      background: rgba(76, 175, 80, 0.3);
      border: 2px solid #4caf50;
    }

    .achievement-badge.locked {
      opacity: 0.4;
    }

    .achievement-icon {
      font-size: 32px;
      margin-bottom: 5px;
    }

    .achievement-name {
      font-size: 10px;
      word-wrap: break-word;
    }

    .achievement-tooltip {
      position: relative;
    }

    .gamification-settings {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }

    .celebration-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 9999;
    }

    .completion-animation {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 300px;
      pointer-events: none;
      z-index: 10000;
    }

    .xp-popup {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
      z-index: 10001;
      animation: slideIn 0.3s ease-out, slideOut 0.3s ease-in 2.7s;
      animation-fill-mode: forwards;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(400px);
        opacity: 0;
      }
    }

    .xp-popup-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .xp-popup-amount {
      font-size: 32px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
      <h1>üîî Notification Engine - Task Management</h1>
      <div style="display: flex; gap: 10px;">
        <button onclick="window.location.href='tasks.html'" style="background: #4299e1; padding: 10px 20px; color: white; border: none; border-radius: 6px; cursor: pointer;">
          ‚úì Task Manager & Timer
        </button>
        <button onclick="window.location.href='analytics.html'" style="background: #667eea; padding: 10px 20px; color: white; border: none; border-radius: 6px; cursor: pointer;">
          üìä View Analytics Dashboards
        </button>
      </div>
    </div>

    <!-- Daily Stats -->
    <div class="section">
      <h2>Daily Statistics</h2>
      <div class="stats">
        <div class="stat-card">
          <div class="stat-value" id="tasksCompleted">0</div>
          <div class="stat-label">Tasks Completed</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="focusTime">0</div>
          <div class="stat-label">Focus Time (min)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="breakTime">0</div>
          <div class="stat-label">Break Time (min)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="streak">0</div>
          <div class="stat-label">Day Streak</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="pendingRollovers">0</div>
          <div class="stat-label">Pending Rollovers</div>
        </div>
      </div>
    </div>

    <!-- Gamification Widget -->
    <div class="section">
      <div class="gamification-widget" id="gamificationWidget">
        <h2 style="margin-bottom: 20px;">üèÜ Your Progress</h2>
        
        <!-- XP and Level -->
        <div class="xp-section">
          <div class="xp-value" id="totalXP">0 XP</div>
          <div class="xp-label">Total Experience</div>
        </div>
        
        <div class="level-info">
          <div class="level-badge" id="currentLevel">Level 1</div>
          <div id="xpToNextLevel">0 / 100 XP</div>
        </div>
        
        <div class="progress-bar">
          <div class="progress-fill" id="levelProgress" style="width: 0%"></div>
        </div>
        
        <!-- Daily and Weekly Goals -->
        <div class="goals-section">
          <div class="goal-card">
            <div class="goal-title">Daily Tasks</div>
            <div class="goal-progress" id="dailyTasksProgress">0 / 5</div>
            <div class="goal-bar">
              <div class="goal-bar-fill" id="dailyTasksBar" style="width: 0%"></div>
            </div>
          </div>
          <div class="goal-card">
            <div class="goal-title">Daily Focus (min)</div>
            <div class="goal-progress" id="dailyFocusProgress">0 / 120</div>
            <div class="goal-bar">
              <div class="goal-bar-fill" id="dailyFocusBar" style="width: 0%"></div>
            </div>
          </div>
          <div class="goal-card">
            <div class="goal-title">Weekly Tasks</div>
            <div class="goal-progress" id="weeklyTasksProgress">0 / 25</div>
            <div class="goal-bar">
              <div class="goal-bar-fill" id="weeklyTasksBar" style="width: 0%"></div>
            </div>
          </div>
          <div class="goal-card">
            <div class="goal-title">Weekly Focus (min)</div>
            <div class="goal-progress" id="weeklyFocusProgress">0 / 600</div>
            <div class="goal-bar">
              <div class="goal-bar-fill" id="weeklyFocusBar" style="width: 0%"></div>
            </div>
          </div>
        </div>
        
        <!-- Achievements -->
        <div class="achievements-section">
          <h3 style="font-size: 16px; margin-bottom: 10px;">Achievements</h3>
          <div class="achievements-grid" id="achievementsGrid">
            <!-- Achievements will be populated here -->
          </div>
        </div>
        
        <!-- Gamification Settings -->
        <div class="gamification-settings">
          <div class="control-group" style="color: white;">
            <label for="confettiEnabled" style="color: white;">Confetti Effects</label>
            <input type="checkbox" id="confettiEnabled" checked>
          </div>
          <div class="control-group" style="color: white; margin-top: 10px;">
            <label for="animationEnabled" style="color: white;">Animations</label>
            <input type="checkbox" id="animationEnabled" checked>
          </div>
          <div class="control-group" style="color: white; margin-top: 10px;">
            <label for="soundEnabled" style="color: white;">Sound Effects</label>
            <input type="checkbox" id="soundEnabled" checked>
          </div>
          <button onclick="testTaskCompletion()" style="margin-top: 15px; width: 100%;">üéØ Test Task Completion</button>
        </div>
      </div>
    </div>

    <!-- Notification Settings -->
    <div class="section">
      <h2>Notification Settings</h2>
      <div class="controls">
        <div class="control-group">
          <label for="taskReminders">Task Reminders</label>
          <input type="checkbox" id="taskReminders">
        </div>
        <div class="control-group">
          <label for="overdueAlerts">Overdue Alerts</label>
          <input type="checkbox" id="overdueAlerts">
        </div>
        <div class="control-group">
          <label for="endOfDaySummary">End-of-Day Summary</label>
          <input type="checkbox" id="endOfDaySummary">
        </div>
      </div>
    </div>

    <!-- Quiet Hours -->
    <div class="section">
      <h2>Quiet Hours</h2>
      <div class="controls">
        <div class="control-group">
          <label for="quietHoursEnabled">Enable Quiet Hours</label>
          <input type="checkbox" id="quietHoursEnabled">
        </div>
        <div class="control-group">
          <label for="quietHoursStart">Start Time</label>
          <input type="time" id="quietHoursStart">
        </div>
        <div class="control-group">
          <label for="quietHoursEnd">End Time</label>
          <input type="time" id="quietHoursEnd">
        </div>
      </div>
    </div>

    <!-- End-of-Day Time -->
    <div class="section">
      <h2>End-of-Day Summary Time</h2>
      <div class="controls">
        <div class="control-group">
          <label for="eodTime">Summary Time</label>
          <input type="time" id="eodTime">
        </div>
      </div>
    </div>

    <!-- Pomodoro Settings -->
    <div class="section">
      <h2>üçÖ Pomodoro Mode</h2>
      <div class="controls">
        <div class="control-group">
          <label for="pomodoroEnabled">Enable Pomodoro Mode</label>
          <input type="checkbox" id="pomodoroEnabled">
        </div>
        <div class="control-group">
          <label for="pomodoroWorkDuration">Work Duration (minutes)</label>
          <input type="number" id="pomodoroWorkDuration" min="1" max="60" value="25" style="width: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
        <div class="control-group">
          <label for="pomodoroBreakDuration">Break Duration (minutes)</label>
          <input type="number" id="pomodoroBreakDuration" min="1" max="30" value="5" style="width: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
        <div class="control-group">
          <label for="pomodoroLongBreakDuration">Long Break Duration (minutes)</label>
          <input type="number" id="pomodoroLongBreakDuration" min="1" max="60" value="15" style="width: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
      </div>
    </div>

    <!-- Pomodoro Timer -->
    <div class="section" id="pomodoroTimerSection" style="display: none;">
      <h2>Pomodoro Timer</h2>
      <div style="text-align: center; margin: 20px 0;">
        <div style="font-size: 48px; font-weight: bold; color: #667eea; margin-bottom: 10px;" id="pomodoroTimer">25:00</div>
        <div style="font-size: 18px; color: #666; margin-bottom: 20px;" id="pomodoroPhase">Ready to work</div>
        <div style="font-size: 14px; color: #999; margin-bottom: 20px;" id="pomodoroCycle">Cycle 1</div>
      </div>
      <div class="test-buttons" style="justify-content: center;">
        <button onclick="startPomodoroWork()">‚ñ∂Ô∏è Start Work</button>
        <button onclick="pausePomodoro()">‚è∏Ô∏è Pause</button>
        <button onclick="resumePomodoro()">‚ñ∂Ô∏è Resume</button>
        <button onclick="skipPomodoro()">‚è≠Ô∏è Skip</button>
        <button onclick="extendPomodoro()">‚è±Ô∏è +5 min</button>
      </div>
      <div style="margin-top: 20px;">
        <h3 style="font-size: 14px; color: #666; margin-bottom: 10px;">Upcoming Cycles:</h3>
        <div id="upcomingCycles" style="font-size: 12px; color: #888;"></div>
      </div>
    </div>

    <!-- Break Reminder Settings -->
    <div class="section">
      <h2>Break Reminders</h2>
      <div class="controls">
        <div class="control-group">
          <label for="breakReminderEnabled">Enable Break Reminders (non-Pomodoro)</label>
          <input type="checkbox" id="breakReminderEnabled">
        </div>
        <div class="control-group">
          <label for="breakReminderInterval">Remind After (minutes)</label>
          <input type="number" id="breakReminderInterval" min="15" max="180" value="60" style="width: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
      </div>
    </div>

    <!-- Timer Analytics -->
    <div class="section">
      <h2>Focus & Break Analytics</h2>
      <div id="analyticsContent">
        <p style="color: #999;">Loading analytics...</p>
      </div>
    </div>

    <!-- Test Notifications -->
    <div class="section">
      <h2>Test Notifications</h2>
      <div class="test-buttons">
        <button onclick="testNotification('reminder')">Test Task Reminder</button>
        <button onclick="testNotification('overdue')">Test Overdue Alert</button>
        <button onclick="testNotification('summary')">Test Daily Summary</button>
        <button class="secondary" onclick="triggerSummary()">Trigger Daily Summary Now</button>
      </div>
    </div>

    <!-- Focus Monitoring Settings -->
    <div class="section">
      <h2>Focus Monitoring</h2>
      <div class="controls">
        <div class="control-group">
          <label for="focusMonitoringEnabled">Enable Focus Monitoring</label>
          <input type="checkbox" id="focusMonitoringEnabled" onchange="toggleFocusMonitoring(this.checked)">
        </div>
        <div class="control-group">
          <label for="graceCountdownDuration">Grace Period (seconds)</label>
          <input type="number" id="graceCountdownDuration" min="5" max="60" value="10" onchange="updateGraceCountdown(this.value)">
        </div>
      </div>

      <!-- Whitelist Management -->
      <h3 style="margin-top: 20px;">Whitelist (Allowed Apps/URLs)</h3>
      <div style="margin-bottom: 10px; display: flex; gap: 10px;">
        <select id="whitelistType" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
          <option value="app">App</option>
          <option value="url">URL Pattern</option>
        </select>
        <input type="text" id="whitelistPattern" placeholder="e.g., Chrome, slack.com/*" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        <button onclick="addToWhitelist()">Add</button>
      </div>
      <div id="whitelistItems" style="margin-bottom: 20px;"></div>

      <!-- Blacklist Management -->
      <h3>Blacklist (Blocked Apps/URLs)</h3>
      <div style="margin-bottom: 10px; display: flex; gap: 10px;">
        <select id="blacklistType" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
          <option value="app">App</option>
          <option value="url">URL Pattern</option>
        </select>
        <input type="text" id="blacklistPattern" placeholder="e.g., Facebook, twitter.com/*" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        <button onclick="addToBlacklist()">Add</button>
      </div>
      <div id="blacklistItems" style="margin-bottom: 20px;"></div>
    </div>

    <!-- Focus Activity Panel -->
    <div class="section">
      <h2>Focus Activity - Distraction Log</h2>
      <div style="margin-bottom: 15px;">
        <button onclick="refreshDistractionLog()">Refresh</button>
        <button onclick="clearDistractionLog()" class="secondary">Clear All</button>
      </div>
      <div id="distractionLog">
        <p style="color: #999; padding: 20px; text-align: center;">No distractions logged yet</p>
      </div>
    </div>

    <!-- Grace Countdown Banner -->
    <div id="graceCountdownBanner" style="display: none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #ff9800; color: white; padding: 15px 30px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); z-index: 1000; min-width: 400px; text-align: center;">
      <div style="font-weight: bold; margin-bottom: 5px;">‚ö†Ô∏è Focus Warning</div>
      <div id="graceCountdownText">Returning focus in <span id="graceCountdownSeconds">10</span> seconds...</div>
      <div style="margin-top: 10px; font-size: 12px; opacity: 0.9;">Return to the app to cancel timer pause</div>
    </div>

    <!-- Inbox -->
    <div class="section">
      <h2>Notification Inbox (<span id="unreadCount">0</span> unread)</h2>
      <button onclick="markAllAsRead()" style="margin-bottom: 15px;">Mark All as Read</button>
      <div class="inbox-list" id="inboxList">
        <p style="color: #999; padding: 20px; text-align: center;">No notifications yet</p>
      </div>
    </div>

    <!-- Status -->
    <div id="statusMessage"></div>
  </div>

  <!-- Celebration Overlay -->
  <canvas id="confettiCanvas" class="celebration-overlay"></canvas>
  <div id="animationContainer" class="completion-animation"></div>

  <!-- Load external libraries -->
  <script src="../node_modules/canvas-confetti/dist/confetti.browser.js"></script>
  <script src="../node_modules/lottie-web/build/player/lottie.min.js"></script>
  <script src="services/StorageService.js"></script>

  <script>
    // Initialize
    let currentSettings = {};
    let pomodoroStatus = null;

    // Gamification state
    let storageService = null;
    let gamificationState = null;
    let unlockedAchievements = [];

    // Load settings and stats on startup
    async function initialize() {
      await loadSettings();
      await loadDailyStats();
      await loadInbox();
      await loadPomodoroSettings();
      await loadTimerSettings();
      await loadAnalytics();
      await initializeGamification();
      await loadFocusMonitoringSettings();
      setupPomodoroEventListeners();
      setupFocusMonitoringEventListeners();
    }

    // Initialize gamification system
    async function initializeGamification() {
      try {
        // Initialize IndexedDB storage
        storageService = new StorageService();
        await storageService.initialize();

        // Load gamification state
        gamificationState = await storageService.getGamificationState();
        const achievements = await storageService.getUnlockedAchievements();
        unlockedAchievements = achievements.map(a => a.id);

        // Load settings
        const settings = await window.notificationAPI.gamificationGetSettings();
        document.getElementById('confettiEnabled').checked = settings.confettiEnabled;
        document.getElementById('animationEnabled').checked = settings.animationEnabled;
        document.getElementById('soundEnabled').checked = settings.soundEnabled;

        // Update UI
        await updateGamificationUI();

        console.log('Gamification initialized:', gamificationState);
      } catch (error) {
        console.error('Failed to initialize gamification:', error);
      }
    }

    // Update gamification UI
    async function updateGamificationUI() {
      try {
        // Update XP and Level
        document.getElementById('totalXP').textContent = `${gamificationState.totalXP} XP`;
        document.getElementById('currentLevel').textContent = `Level ${gamificationState.level}`;

        // Update level progress
        const progress = await window.notificationAPI.gamificationGetLevelProgress(
          gamificationState.totalXP,
          gamificationState.level
        );
        document.getElementById('levelProgress').style.width = `${progress.percentage}%`;
        document.getElementById('xpToNextLevel').textContent = `${progress.current} / ${progress.needed} XP`;

        // Update daily stats
        const todayStats = await storageService.getTodayStats();
        const dailyGoals = await window.notificationAPI.gamificationGetDailyGoalProgress(todayStats);
        
        document.getElementById('dailyTasksProgress').textContent = 
          `${dailyGoals.tasks.current} / ${dailyGoals.tasks.goal}`;
        document.getElementById('dailyTasksBar').style.width = `${dailyGoals.tasks.percentage}%`;
        
        document.getElementById('dailyFocusProgress').textContent = 
          `${dailyGoals.focusTime.current} / ${dailyGoals.focusTime.goal}`;
        document.getElementById('dailyFocusBar').style.width = `${dailyGoals.focusTime.percentage}%`;

        // Update weekly stats
        const weekStats = await storageService.getWeekStats();
        const weeklyGoals = await window.notificationAPI.gamificationGetWeeklyGoalProgress(weekStats);
        
        document.getElementById('weeklyTasksProgress').textContent = 
          `${weeklyGoals.tasks.current} / ${weeklyGoals.tasks.goal}`;
        document.getElementById('weeklyTasksBar').style.width = `${weeklyGoals.tasks.percentage}%`;
        
        document.getElementById('weeklyFocusProgress').textContent = 
          `${weeklyGoals.focusTime.current} / ${weeklyGoals.focusTime.goal}`;
        document.getElementById('weeklyFocusBar').style.width = `${weeklyGoals.focusTime.percentage}%`;

        // Update achievements
        await updateAchievementsUI();

      } catch (error) {
        console.error('Failed to update gamification UI:', error);
      }
    }

    // Update achievements UI
    async function updateAchievementsUI() {
      try {
        const allAchievements = await window.notificationAPI.gamificationGetAllAchievements();
        const grid = document.getElementById('achievementsGrid');
        
        grid.innerHTML = allAchievements.map(achievement => {
          const unlocked = unlockedAchievements.includes(achievement.id);
          return `
            <div class="achievement-badge ${unlocked ? 'unlocked' : 'locked'}" 
                 title="${achievement.description}">
              <div class="achievement-icon">${achievement.icon}</div>
              <div class="achievement-name">${achievement.name}</div>
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('Failed to update achievements UI:', error);
      }
    }

    // Handle task completion
    async function onTaskCompleted(taskData) {
      try {
        // Add current streak to taskData for XP calculation
        taskData.currentStreak = gamificationState.currentStreak;

        // Calculate XP for this task
        const xpEarned = await window.notificationAPI.gamificationCalculateXP(taskData);

        // Update streak
        const streakUpdate = await window.notificationAPI.gamificationUpdateStreak(
          gamificationState.lastCompletionDate
        );
        if (streakUpdate) {
          gamificationState.currentStreak = streakUpdate.currentStreak;
          gamificationState.longestStreak = streakUpdate.longestStreak;
          gamificationState.lastCompletionDate = streakUpdate.lastCompletionDate;
        }

        // Update total XP and level
        const oldLevel = gamificationState.level;
        gamificationState.totalXP += xpEarned;
        gamificationState.totalTasksCompleted += 1;
        
        // Track beat estimate
        if (taskData.estimatedTime && taskData.actualTime) {
          const percentDiff = (taskData.estimatedTime - taskData.actualTime) / taskData.estimatedTime;
          if (percentDiff >= 0.2) {
            gamificationState.beatEstimateCount += 1;
          }
        }

        const newLevel = await window.notificationAPI.gamificationCalculateLevel(gamificationState.totalXP);
        gamificationState.level = newLevel;

        // Update daily and weekly stats
        const today = new Date().toISOString().split('T')[0];
        await storageService.updateDailyStats(today, {
          tasksCompleted: (await storageService.getTodayStats()).tasksCompleted + 1,
          focusTime: (await storageService.getTodayStats()).focusTime + (taskData.focusTime || 0)
        });

        await storageService.updateWeekStats({
          tasksCompleted: (await storageService.getWeekStats()).tasksCompleted + 1,
          focusTime: (await storageService.getWeekStats()).focusTime + (taskData.focusTime || 0)
        });

        // Save state
        await storageService.saveGamificationState(gamificationState);

        // Check for new achievements
        const stats = {
          ...gamificationState,
          todayFocusTime: (await storageService.getTodayStats()).focusTime
        };
        const newAchievements = await window.notificationAPI.gamificationCheckAchievements(
          stats,
          unlockedAchievements
        );

        // Unlock new achievements
        for (const achievement of newAchievements) {
          await storageService.unlockAchievement(achievement);
          unlockedAchievements.push(achievement.id);
        }

        // Show celebration
        await showTaskCompletionCelebration(xpEarned, newLevel > oldLevel, newAchievements);

        // Update UI
        await updateGamificationUI();

      } catch (error) {
        console.error('Failed to handle task completion:', error);
      }
    }

    // Show celebration effects
    async function showTaskCompletionCelebration(xpEarned, leveledUp, newAchievements) {
      const settings = await window.notificationAPI.gamificationGetSettings();

      // Show XP popup
      showXPPopup(xpEarned, leveledUp);

      // Confetti effect
      if (settings.confettiEnabled) {
        triggerConfetti();
      }

      // Checkmark animation
      if (settings.animationEnabled) {
        showCheckmarkAnimation();
      }

      // Sound effect
      if (settings.soundEnabled) {
        playCompletionSound();
      }

      // Show achievement notifications
      if (newAchievements && newAchievements.length > 0) {
        for (const achievement of newAchievements) {
          setTimeout(() => {
            showAchievementNotification(achievement);
          }, 1000);
        }
      }
    }

    // Show XP popup
    function showXPPopup(xpEarned, leveledUp) {
      const popup = document.createElement('div');
      popup.className = 'xp-popup';
      popup.innerHTML = `
        <div class="xp-popup-title">${leveledUp ? 'üéâ Level Up!' : '‚úÖ Task Completed!'}</div>
        <div class="xp-popup-amount">+${xpEarned} XP</div>
      `;
      document.body.appendChild(popup);

      setTimeout(() => {
        popup.remove();
      }, 3000);
    }

    // Trigger confetti
    function triggerConfetti() {
      const canvas = document.getElementById('confettiCanvas');
      const myConfetti = confetti.create(canvas, {
        resize: true,
        useWorker: true
      });

      myConfetti({
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 }
      });
    }

    // Show checkmark animation
    function showCheckmarkAnimation() {
      const container = document.getElementById('animationContainer');
      container.style.display = 'block';
      
      // Simple checkmark animation using CSS
      container.innerHTML = `
        <svg viewBox="0 0 100 100" style="width: 100%; height: 100%;">
          <circle cx="50" cy="50" r="45" fill="#4caf50" />
          <path d="M 25 50 L 40 65 L 75 30" stroke="white" stroke-width="8" 
                fill="none" stroke-linecap="round" stroke-linejoin="round"
                style="stroke-dasharray: 100; stroke-dashoffset: 100; animation: draw 0.5s ease-out forwards;" />
        </svg>
        <style>
          @keyframes draw {
            to { stroke-dashoffset: 0; }
          }
        </style>
      `;

      setTimeout(() => {
        container.style.display = 'none';
        container.innerHTML = '';
      }, 1500);
    }

    // Play completion sound
    function playCompletionSound() {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
      oscillator.type = 'sine';

      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);

      // Second tone
      const oscillator2 = audioContext.createOscillator();
      const gainNode2 = audioContext.createGain();
      
      oscillator2.connect(gainNode2);
      gainNode2.connect(audioContext.destination);
      
      oscillator2.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
      oscillator2.type = 'sine';
      
      gainNode2.gain.setValueAtTime(0.3, audioContext.currentTime + 0.1);
      gainNode2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
      
      oscillator2.start(audioContext.currentTime + 0.1);
      oscillator2.stop(audioContext.currentTime + 0.4);
    }

    // Show achievement notification
    function showAchievementNotification(achievement) {
      const notification = document.createElement('div');
      notification.className = 'xp-popup';
      notification.innerHTML = `
        <div class="xp-popup-title">üèÜ Achievement Unlocked!</div>
        <div style="font-size: 48px; margin: 10px 0;">${achievement.icon}</div>
        <div style="font-size: 18px; font-weight: bold;">${achievement.name}</div>
        <div style="font-size: 14px; opacity: 0.9;">${achievement.description}</div>
      `;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.remove();
      }, 4000);
    }

    // Test task completion function
    async function testTaskCompletion() {
      await onTaskCompleted({
        focusTime: 25,
        estimatedTime: 30,
        actualTime: 23
      });
    }

    // Event listeners for gamification settings
    document.getElementById('confettiEnabled').addEventListener('change', async (e) => {
      await window.notificationAPI.gamificationSetConfettiEnabled(e.target.checked);
    });

    document.getElementById('animationEnabled').addEventListener('change', async (e) => {
      await window.notificationAPI.gamificationSetAnimationEnabled(e.target.checked);
    });

    document.getElementById('soundEnabled').addEventListener('change', async (e) => {
      await window.notificationAPI.gamificationSetSoundEnabled(e.target.checked);
    });

    // Load settings
    async function loadSettings() {
      try {
        const settings = await window.notificationAPI.getSettings();
        currentSettings = settings;

        // Apply to UI
        document.getElementById('taskReminders').checked = settings.notifications.taskReminders;
        document.getElementById('overdueAlerts').checked = settings.notifications.overdueAlerts;
        document.getElementById('endOfDaySummary').checked = settings.notifications.endOfDaySummary;
        document.getElementById('quietHoursEnabled').checked = settings.notifications.quietHours.enabled;
        document.getElementById('quietHoursStart').value = settings.notifications.quietHours.start;
        document.getElementById('quietHoursEnd').value = settings.notifications.quietHours.end;
        document.getElementById('eodTime').value = settings.endOfDay.summaryTime;

        showStatus('Settings loaded successfully');
      } catch (error) {
        showStatus('Failed to load settings: ' + error.message, true);
      }
    }

    // Load daily stats
    async function loadDailyStats() {
      try {
        const stats = await window.notificationAPI.getDailyStats();
        
        document.getElementById('tasksCompleted').textContent = stats.tasksCompleted;
        document.getElementById('focusTime').textContent = stats.focusTime;
        document.getElementById('breakTime').textContent = stats.breakTime || 0;
        document.getElementById('streak').textContent = stats.streak;
        document.getElementById('pendingRollovers').textContent = stats.pendingRollovers;
      } catch (error) {
        showStatus('Failed to load daily stats: ' + error.message, true);
      }
    }

    // Load inbox
    async function loadInbox() {
      try {
        const items = await window.notificationAPI.getInboxItems();
        const unreadCount = await window.notificationAPI.getUnreadCount();
        
        document.getElementById('unreadCount').textContent = unreadCount;
        
        const inboxList = document.getElementById('inboxList');
        
        if (items.length === 0) {
          inboxList.innerHTML = '<p style="color: #999; padding: 20px; text-align: center;">No notifications yet</p>';
          return;
        }
        
        inboxList.innerHTML = items.map(item => `
          <div class="inbox-item ${item.read ? '' : 'unread'}">
            <div class="inbox-content">
              <div class="inbox-date">${new Date(item.timestamp).toLocaleString()}</div>
              <div class="inbox-data">${formatInboxData(item)}</div>
            </div>
          </div>
        `).join('');
      } catch (error) {
        showStatus('Failed to load inbox: ' + error.message, true);
      }
    }

    // Format inbox data
    function formatInboxData(item) {
      if (item.type === 'dailySummary') {
        const data = item.data;
        return `üìä Daily Summary: ${data.tasksCompleted} tasks, ${data.focusTime} min focus, ${data.streak} day streak`;
      }
      return JSON.stringify(item.data);
    }

    // Event listeners for settings
    document.getElementById('taskReminders').addEventListener('change', async (e) => {
      await window.notificationAPI.setTaskReminders(e.target.checked);
      showStatus('Task reminders ' + (e.target.checked ? 'enabled' : 'disabled'));
    });

    document.getElementById('overdueAlerts').addEventListener('change', async (e) => {
      await window.notificationAPI.setOverdueAlerts(e.target.checked);
      showStatus('Overdue alerts ' + (e.target.checked ? 'enabled' : 'disabled'));
    });

    document.getElementById('endOfDaySummary').addEventListener('change', async (e) => {
      await window.notificationAPI.setEndOfDaySummary(e.target.checked);
      showStatus('End-of-day summary ' + (e.target.checked ? 'enabled' : 'disabled'));
    });

    document.getElementById('quietHoursEnabled').addEventListener('change', async (e) => {
      await window.notificationAPI.setQuietHours({
        enabled: e.target.checked
      });
      showStatus('Quiet hours ' + (e.target.checked ? 'enabled' : 'disabled'));
    });

    document.getElementById('quietHoursStart').addEventListener('change', async (e) => {
      await window.notificationAPI.setQuietHours({
        start: e.target.value
      });
      showStatus('Quiet hours start time updated');
    });

    document.getElementById('quietHoursEnd').addEventListener('change', async (e) => {
      await window.notificationAPI.setQuietHours({
        end: e.target.value
      });
      showStatus('Quiet hours end time updated');
    });

    document.getElementById('eodTime').addEventListener('change', async (e) => {
      await window.notificationAPI.setEndOfDayTime(e.target.value);
      showStatus('End-of-day summary time updated');
    });

    // Test notification
    async function testNotification(type) {
      try {
        await window.notificationAPI.testNotification(type);
        showStatus('Test notification sent: ' + type);
      } catch (error) {
        showStatus('Failed to send test notification: ' + error.message, true);
      }
    }

    // Trigger summary
    async function triggerSummary() {
      try {
        await window.notificationAPI.triggerSummary();
        showStatus('Daily summary triggered');
        setTimeout(loadInbox, 1000);
      } catch (error) {
        showStatus('Failed to trigger summary: ' + error.message, true);
      }
    }

    // Mark all as read
    async function markAllAsRead() {
      try {
        await window.notificationAPI.markAllAsRead();
        showStatus('All notifications marked as read');
        loadInbox();
      } catch (error) {
        showStatus('Failed to mark as read: ' + error.message, true);
      }
    }

    // Show status message
    function showStatus(message, isError = false) {
      const statusEl = document.getElementById('statusMessage');
      statusEl.textContent = message;
      statusEl.className = 'status' + (isError ? ' error' : '');
      
      setTimeout(() => {
        statusEl.textContent = '';
        statusEl.className = '';
      }, 5000);
    }

    // Listen for notification events
    window.notificationAPI.onNotificationClicked((data) => {
      console.log('Notification clicked:', data);
      showStatus('Notification clicked: ' + data.type);
    });

    window.notificationAPI.onTaskAction((data) => {
      console.log('Task action:', data);
      showStatus('Task action: ' + data.action);
      loadDailyStats();
    });

    // Load Pomodoro settings
    async function loadPomodoroSettings() {
      try {
        const settings = await window.notificationAPI.pomodoroGetSettings();
        
        document.getElementById('pomodoroEnabled').checked = settings.enabled;
        document.getElementById('pomodoroWorkDuration').value = settings.workDuration;
        document.getElementById('pomodoroBreakDuration').value = settings.breakDuration;
        document.getElementById('pomodoroLongBreakDuration').value = settings.longBreakDuration;
        
        // Show/hide timer section based on enabled state
        document.getElementById('pomodoroTimerSection').style.display = settings.enabled ? 'block' : 'none';
        
        if (settings.enabled) {
          await updatePomodoroStatus();
          await updateUpcomingCycles();
        }
      } catch (error) {
        console.error('Failed to load Pomodoro settings:', error);
      }
    }

    // Load Timer settings
    async function loadTimerSettings() {
      try {
        const settings = await window.notificationAPI.timerGetSettings();
        
        document.getElementById('breakReminderEnabled').checked = settings.breakReminderEnabled;
        document.getElementById('breakReminderInterval').value = settings.breakReminderInterval;
      } catch (error) {
        console.error('Failed to load Timer settings:', error);
      }
    }

    // Load analytics
    async function loadAnalytics() {
      try {
        const analytics = await window.notificationAPI.timerGetAnalytics();
        const content = document.getElementById('analyticsContent');
        
        content.innerHTML = `
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
            <div style="padding: 15px; background: #f9f9f9; border-radius: 4px;">
              <div style="font-size: 24px; font-weight: bold; color: #667eea;">${analytics.focusSessions.count}</div>
              <div style="font-size: 12px; color: #666;">Focus Sessions</div>
              <div style="font-size: 12px; color: #999;">${analytics.focusSessions.totalMinutes} min total</div>
            </div>
            <div style="padding: 15px; background: #f9f9f9; border-radius: 4px;">
              <div style="font-size: 24px; font-weight: bold; color: #764ba2;">${analytics.breakSessions.count}</div>
              <div style="font-size: 12px; color: #666;">Break Sessions</div>
              <div style="font-size: 12px; color: #999;">${analytics.breakSessions.totalMinutes} min total</div>
            </div>
            <div style="padding: 15px; background: #f9f9f9; border-radius: 4px;">
              <div style="font-size: 24px; font-weight: bold; color: #4caf50;">${analytics.focusBreakRatio}</div>
              <div style="font-size: 12px; color: #666;">Focus/Break Ratio</div>
              <div style="font-size: 12px; color: #999;">Last 7 days</div>
            </div>
            <div style="padding: 15px; background: #f9f9f9; border-radius: 4px;">
              <div style="font-size: 24px; font-weight: bold; color: #ff9800;">${analytics.focusSessions.pomodoroCount}</div>
              <div style="font-size: 12px; color: #666;">Pomodoro Sessions</div>
              <div style="font-size: 12px; color: #999;">${analytics.breakSessions.longBreaks} long breaks</div>
            </div>
          </div>
        `;
      } catch (error) {
        console.error('Failed to load analytics:', error);
      }
    }

    // Update Pomodoro status
    async function updatePomodoroStatus() {
      try {
        pomodoroStatus = await window.notificationAPI.pomodoroGetStatus();
        
        if (pomodoroStatus.phase) {
          const minutes = Math.floor(pomodoroStatus.remainingSeconds / 60);
          const seconds = pomodoroStatus.remainingSeconds % 60;
          document.getElementById('pomodoroTimer').textContent = 
            `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
          
          document.getElementById('pomodoroPhase').textContent = 
            pomodoroStatus.phase === 'work' ? 'üíº Work Session' : '‚òï Break Time';
          
          document.getElementById('pomodoroCycle').textContent = 
            `Cycle ${pomodoroStatus.currentCycle + 1}`;
        }
      } catch (error) {
        console.error('Failed to update Pomodoro status:', error);
      }
    }

    // Update upcoming cycles
    async function updateUpcomingCycles() {
      try {
        const cycles = await window.notificationAPI.pomodoroGetUpcomingCycles(5);
        const content = cycles.map(c => 
          `Cycle ${c.cycle}: ${c.workDuration}m work ‚Üí ${c.breakDuration}m ${c.isLongBreak ? 'long ' : ''}break`
        ).join('<br>');
        document.getElementById('upcomingCycles').innerHTML = content;
      } catch (error) {
        console.error('Failed to update upcoming cycles:', error);
      }
    }

    // Pomodoro controls
    async function startPomodoroWork() {
      try {
        await window.notificationAPI.pomodoroStartWork(null);
        showStatus('Pomodoro work session started');
      } catch (error) {
        showStatus('Failed to start work session: ' + error.message, true);
      }
    }

    async function pausePomodoro() {
      try {
        await window.notificationAPI.pomodoroPause();
        showStatus('Pomodoro paused');
      } catch (error) {
        showStatus('Failed to pause: ' + error.message, true);
      }
    }

    async function resumePomodoro() {
      try {
        await window.notificationAPI.pomodoroResume();
        showStatus('Pomodoro resumed');
      } catch (error) {
        showStatus('Failed to resume: ' + error.message, true);
      }
    }

    async function skipPomodoro() {
      try {
        await window.notificationAPI.pomodoroSkip();
        showStatus('Session skipped');
      } catch (error) {
        showStatus('Failed to skip: ' + error.message, true);
      }
    }

    async function extendPomodoro() {
      try {
        await window.notificationAPI.pomodoroExtend(5);
        showStatus('Session extended by 5 minutes');
      } catch (error) {
        showStatus('Failed to extend: ' + error.message, true);
      }
    }

    // Setup Pomodoro event listeners
    function setupPomodoroEventListeners() {
      window.notificationAPI.onPomodoroTimerTick((data) => {
        const minutes = Math.floor(data.remainingSeconds / 60);
        const seconds = data.remainingSeconds % 60;
        document.getElementById('pomodoroTimer').textContent = 
          `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      });

      window.notificationAPI.onPomodoroWorkStarted((data) => {
        document.getElementById('pomodoroPhase').textContent = 'üíº Work Session';
        document.getElementById('pomodoroCycle').textContent = `Cycle ${data.cycle}`;
        showStatus('Work session started!');
      });

      window.notificationAPI.onPomodoroBreakStarted((data) => {
        document.getElementById('pomodoroPhase').textContent = data.isLongBreak ? 'üåü Long Break' : '‚òï Break Time';
        showStatus(data.isLongBreak ? 'Long break started!' : 'Break started!');
      });

      window.notificationAPI.onPomodoroSessionCompleted((data) => {
        loadDailyStats();
        loadAnalytics();
      });
    }

    // Event listeners for Pomodoro settings
    document.getElementById('pomodoroEnabled').addEventListener('change', async (e) => {
      try {
        if (e.target.checked) {
          await window.notificationAPI.pomodoroEnable();
          document.getElementById('pomodoroTimerSection').style.display = 'block';
          await updatePomodoroStatus();
          await updateUpcomingCycles();
        } else {
          await window.notificationAPI.pomodoroDisable();
          document.getElementById('pomodoroTimerSection').style.display = 'none';
        }
        showStatus('Pomodoro mode ' + (e.target.checked ? 'enabled' : 'disabled'));
      } catch (error) {
        showStatus('Failed to toggle Pomodoro: ' + error.message, true);
      }
    });

    document.getElementById('pomodoroWorkDuration').addEventListener('change', async (e) => {
      try {
        await window.notificationAPI.pomodoroUpdateSettings({ workDuration: parseInt(e.target.value) });
        showStatus('Work duration updated');
        await updateUpcomingCycles();
      } catch (error) {
        showStatus('Failed to update work duration: ' + error.message, true);
      }
    });

    document.getElementById('pomodoroBreakDuration').addEventListener('change', async (e) => {
      try {
        await window.notificationAPI.pomodoroUpdateSettings({ breakDuration: parseInt(e.target.value) });
        showStatus('Break duration updated');
        await updateUpcomingCycles();
      } catch (error) {
        showStatus('Failed to update break duration: ' + error.message, true);
      }
    });

    document.getElementById('pomodoroLongBreakDuration').addEventListener('change', async (e) => {
      try {
        await window.notificationAPI.pomodoroUpdateSettings({ longBreakDuration: parseInt(e.target.value) });
        showStatus('Long break duration updated');
        await updateUpcomingCycles();
      } catch (error) {
        showStatus('Failed to update long break duration: ' + error.message, true);
      }
    });

    // Event listeners for Timer settings
    document.getElementById('breakReminderEnabled').addEventListener('change', async (e) => {
      try {
        await window.notificationAPI.timerUpdateSettings({ breakReminderEnabled: e.target.checked });
        showStatus('Break reminders ' + (e.target.checked ? 'enabled' : 'disabled'));
      } catch (error) {
        showStatus('Failed to toggle break reminders: ' + error.message, true);
      }
    });

    document.getElementById('breakReminderInterval').addEventListener('change', async (e) => {
      try {
        await window.notificationAPI.timerUpdateSettings({ breakReminderInterval: parseInt(e.target.value) });
        showStatus('Break reminder interval updated');
      } catch (error) {
        showStatus('Failed to update interval: ' + error.message, true);
      }
    });

    // Focus Monitoring Functions
    let graceCountdownInterval = null;
    let graceCountdownSecondsRemaining = 10;

    async function loadFocusMonitoringSettings() {
      try {
        const settings = await window.notificationAPI.focusMonitoringGetSettings();
        document.getElementById('focusMonitoringEnabled').checked = settings.enabled;
        document.getElementById('graceCountdownDuration').value = settings.graceCountdownDuration;
        
        renderWhitelist(settings.whitelist);
        renderBlacklist(settings.blacklist);
        await refreshDistractionLog();
      } catch (error) {
        console.error('Failed to load focus monitoring settings:', error);
      }
    }

    async function toggleFocusMonitoring(enabled) {
      try {
        await window.notificationAPI.focusMonitoringSetEnabled(enabled);
        showStatus('Focus monitoring ' + (enabled ? 'enabled' : 'disabled'));
      } catch (error) {
        showStatus('Failed to toggle focus monitoring: ' + error.message, true);
      }
    }

    async function updateGraceCountdown(seconds) {
      try {
        await window.notificationAPI.focusMonitoringUpdateSettings({ graceCountdownDuration: parseInt(seconds) });
        showStatus('Grace countdown duration updated');
      } catch (error) {
        showStatus('Failed to update grace countdown: ' + error.message, true);
      }
    }

    function renderWhitelist(whitelist) {
      const container = document.getElementById('whitelistItems');
      if (!whitelist || whitelist.length === 0) {
        container.innerHTML = '<p style="color: #999; padding: 10px;">No whitelist entries</p>';
        return;
      }

      container.innerHTML = whitelist.map((entry, index) => `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #f0f0f0; margin-bottom: 5px; border-radius: 4px;">
          <span><strong>${entry.type}:</strong> ${entry.pattern}</span>
          <button onclick="removeFromWhitelist(${index})" class="secondary" style="padding: 5px 10px; font-size: 12px;">Remove</button>
        </div>
      `).join('');
    }

    function renderBlacklist(blacklist) {
      const container = document.getElementById('blacklistItems');
      if (!blacklist || blacklist.length === 0) {
        container.innerHTML = '<p style="color: #999; padding: 10px;">No blacklist entries</p>';
        return;
      }

      container.innerHTML = blacklist.map((entry, index) => `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #f0f0f0; margin-bottom: 5px; border-radius: 4px;">
          <span><strong>${entry.type}:</strong> ${entry.pattern}</span>
          <button onclick="removeFromBlacklist(${index})" class="secondary" style="padding: 5px 10px; font-size: 12px;">Remove</button>
        </div>
      `).join('');
    }

    async function addToWhitelist() {
      const type = document.getElementById('whitelistType').value;
      const pattern = document.getElementById('whitelistPattern').value.trim();

      if (!pattern) {
        showStatus('Please enter a pattern', true);
        return;
      }

      try {
        await window.notificationAPI.focusMonitoringAddToWhitelist({ type, pattern });
        document.getElementById('whitelistPattern').value = '';
        const settings = await window.notificationAPI.focusMonitoringGetSettings();
        renderWhitelist(settings.whitelist);
        showStatus('Added to whitelist');
      } catch (error) {
        showStatus('Failed to add to whitelist: ' + error.message, true);
      }
    }

    async function removeFromWhitelist(index) {
      try {
        await window.notificationAPI.focusMonitoringRemoveFromWhitelist(index);
        const settings = await window.notificationAPI.focusMonitoringGetSettings();
        renderWhitelist(settings.whitelist);
        showStatus('Removed from whitelist');
      } catch (error) {
        showStatus('Failed to remove from whitelist: ' + error.message, true);
      }
    }

    async function addToBlacklist() {
      const type = document.getElementById('blacklistType').value;
      const pattern = document.getElementById('blacklistPattern').value.trim();

      if (!pattern) {
        showStatus('Please enter a pattern', true);
        return;
      }

      try {
        await window.notificationAPI.focusMonitoringAddToBlacklist({ type, pattern });
        document.getElementById('blacklistPattern').value = '';
        const settings = await window.notificationAPI.focusMonitoringGetSettings();
        renderBlacklist(settings.blacklist);
        showStatus('Added to blacklist');
      } catch (error) {
        showStatus('Failed to add to blacklist: ' + error.message, true);
      }
    }

    async function removeFromBlacklist(index) {
      try {
        await window.notificationAPI.focusMonitoringRemoveFromBlacklist(index);
        const settings = await window.notificationAPI.focusMonitoringGetSettings();
        renderBlacklist(settings.blacklist);
        showStatus('Removed from blacklist');
      } catch (error) {
        showStatus('Failed to remove from blacklist: ' + error.message, true);
      }
    }

    async function refreshDistractionLog() {
      try {
        const log = await window.notificationAPI.focusMonitoringGetDistractionLog(50, 0);
        renderDistractionLog(log);
      } catch (error) {
        console.error('Failed to refresh distraction log:', error);
      }
    }

    function renderDistractionLog(log) {
      const container = document.getElementById('distractionLog');
      
      if (!log || log.length === 0) {
        container.innerHTML = '<p style="color: #999; padding: 20px; text-align: center;">No distractions logged yet</p>';
        return;
      }

      container.innerHTML = log.map(entry => {
        const date = new Date(entry.timestamp);
        const durationSeconds = Math.round(entry.duration / 1000);
        const typeLabel = entry.type === 'blacklisted' ? 'üö´ Blacklisted' : '‚ö†Ô∏è Unfocused';

        return `
          <div style="border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 10px; background: #fafafa;">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
              <div>
                <div style="font-weight: bold; margin-bottom: 5px;">${typeLabel}: ${entry.appName}</div>
                <div style="font-size: 12px; color: #666;">
                  ${date.toLocaleString()} ‚Ä¢ Duration: ${durationSeconds}s
                </div>
                ${entry.windowTitle ? `<div style="font-size: 12px; color: #888; margin-top: 3px;">Window: ${entry.windowTitle}</div>` : ''}
                ${entry.url ? `<div style="font-size: 12px; color: #888;">URL: ${entry.url}</div>` : ''}
              </div>
              <button onclick="deleteDistraction('${entry.id}')" class="secondary" style="padding: 5px 10px; font-size: 12px;">Delete</button>
            </div>
            ${entry.annotation ? 
              `<div style="padding: 10px; background: #fff; border-left: 3px solid #007bff; margin-top: 10px;">
                <strong>Note:</strong> ${entry.annotation}
              </div>` : 
              `<div style="margin-top: 10px;">
                <input type="text" id="annotation-${entry.id}" placeholder="Add a note..." style="width: calc(100% - 80px); padding: 5px; border: 1px solid #ddd; border-radius: 4px; margin-right: 5px;">
                <button onclick="annotateDistraction('${entry.id}')" style="padding: 5px 10px; font-size: 12px;">Save Note</button>
              </div>`
            }
          </div>
        `;
      }).join('');
    }

    async function annotateDistraction(distractionId) {
      const input = document.getElementById(`annotation-${distractionId}`);
      const annotation = input.value.trim();

      if (!annotation) {
        showStatus('Please enter a note', true);
        return;
      }

      try {
        await window.notificationAPI.focusMonitoringAnnotateDistraction(distractionId, annotation);
        await refreshDistractionLog();
        showStatus('Note saved');
      } catch (error) {
        showStatus('Failed to save note: ' + error.message, true);
      }
    }

    async function deleteDistraction(distractionId) {
      try {
        await window.notificationAPI.focusMonitoringDeleteDistraction(distractionId);
        await refreshDistractionLog();
        showStatus('Distraction entry deleted');
      } catch (error) {
        showStatus('Failed to delete entry: ' + error.message, true);
      }
    }

    async function clearDistractionLog() {
      if (!confirm('Are you sure you want to clear the entire distraction log?')) {
        return;
      }

      try {
        await window.notificationAPI.focusMonitoringClearLog();
        await refreshDistractionLog();
        showStatus('Distraction log cleared');
      } catch (error) {
        showStatus('Failed to clear log: ' + error.message, true);
      }
    }

    function setupFocusMonitoringEventListeners() {
      window.notificationAPI.onFocusGraceStarted((data) => {
        showGraceCountdownBanner(data);
      });

      window.notificationAPI.onFocusGraceCancelled(() => {
        hideGraceCountdownBanner();
      });

      window.notificationAPI.onFocusAutoPauseTriggered((data) => {
        hideGraceCountdownBanner();
        showStatus('‚è∏Ô∏è Timer auto-paused due to distraction', true);
        refreshDistractionLog();
      });
    }

    function showGraceCountdownBanner(data) {
      const banner = document.getElementById('graceCountdownBanner');
      const text = data.target.type === 'blacklisted' 
        ? `Blacklisted app detected: ${data.target.name}` 
        : 'You left the app';
      
      document.getElementById('graceCountdownText').innerHTML = 
        `${text}<br>Returning focus in <span id="graceCountdownSeconds">${data.duration}</span> seconds...`;
      
      banner.style.display = 'block';
      graceCountdownSecondsRemaining = data.duration;

      if (graceCountdownInterval) {
        clearInterval(graceCountdownInterval);
      }

      graceCountdownInterval = setInterval(() => {
        graceCountdownSecondsRemaining--;
        document.getElementById('graceCountdownSeconds').textContent = graceCountdownSecondsRemaining;
        
        if (graceCountdownSecondsRemaining <= 0) {
          clearInterval(graceCountdownInterval);
          graceCountdownInterval = null;
        }
      }, 1000);
    }

    function hideGraceCountdownBanner() {
      const banner = document.getElementById('graceCountdownBanner');
      banner.style.display = 'none';
      
      if (graceCountdownInterval) {
        clearInterval(graceCountdownInterval);
        graceCountdownInterval = null;
      }
    }

    // Initialize on load
    initialize();

    // Refresh stats, inbox, and analytics periodically
    setInterval(() => {
      loadDailyStats();
      loadInbox();
      loadAnalytics();
      if (document.getElementById('pomodoroEnabled').checked) {
        updatePomodoroStatus();
      }
      // Refresh distraction log if focus monitoring is enabled
      if (document.getElementById('focusMonitoringEnabled').checked) {
        refreshDistractionLog();
      }
    }, 30000); // Every 30 seconds
  </script>
</body>
</html>
